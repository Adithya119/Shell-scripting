# class-9 notes
# https://directdevops.blog/2020/09/04/linux-classroom-series-04-sept-2020/

# 1) Reading input from files
# 2) Functions (building blocks for Reusability)

----

1) 
Reading input from files:-

script-1.sh  # trainer's file
script-2.sh  # mine

# Firstly, lets understanding of the && operation in the below stmt :-

ping -c1 "${item}" && echo "This server is up: ${item}" >> status.output

# This means, if both ping & echo commands are successful, then only redirect the output to 'status.output'. 

# "echo $?" shows "2" after running 'ping -c1 xcloud.com'. That's why "ping xcloud.com" is not being redirected to 'status.output'. This is the logic behind the use of && in-between the 2 statements.
---

# Secondly, lets understand what is wrong with this stmt (although it doesnt error out, it just doesnt give us what we need exactly) :-

ping -c1 "${item}" && echo "This server is up: ${item}" >> status.output

# This is used in 'script-1.sh' & is redirecting only the echo statement's output & not the ping's output. 1st I tested this on CLI. Because it's only redirecting the last stmt's (echo, in our case) output, it's printing the 1st stmt's (ping, in our case) output on the console screen while execution. ---> this issue is fixed in 'script-2.sh'
---

( ping -c1 "${item}" && echo "This server is up: ${item}" ) >> status.output
# script-2.sh is redirecting both the outputs coz I have enclosed ping && echo stmts within ( ). 1st I tested this on CLI.
---

( ping -c1 "${item}" && echo "This server is up: ${item}" ) >> status.output || echo "${item} is not up"
# redirect to status.output only if both ping & echo commands are successful. If not, print "${item} is not up".

----


2) 
Functions (building blocks for Reusability)

# Definition:-
A 'Function' is a re-usable block of code.  (Refer blog notes for some more content)

Main principle/usage of Function is:- DRY principle (Donâ€™t Repeat Your Self)

We will cover the following aspects:

(i)    Introduction
(ii)   Passing Parameters to the functions
(iii)  Variable scope
(iv)   Returning values from functions
(v)    Recursive functions

(i)    Introduction:-

Run 'declare -F' on CLI (The output of this command might vary with distribution)
# declare -F | less
# ALso try with -f (small f)

# 1) declare -F | grep quote
# 2) type quote
#
quote $USER 
echo $(quote $USER)
# both of the above commands should print the value of USER in quotes, coz that's the logic written inside quote function.
ex:- 'ubuntu', 'ec2-user'
--

# Functions can be created using the following two syntaxes:-

Syntax 1:-

function-name() {
    <code to be executed>
}
--

Syntax 2:-                                 # paranthesis () are not needed if you're defining a function with the 'function' keyword.

function <function-name> {
    <code to be executed>
}

# In these function blocks/syntaxes, we don't have do & done blocks coz we have curly brackets { }

The scope of the function is inside the shell script. That's why it wont print anything unless you call the function:- 
refer 'function-demo.sh' and 'function-2.sh'


# Note:-
While calling a function, dont use () next to it.
--

To make a function available to end users without them having to run a script, you need to export it this way:-

(i) paste this function in the bottom of 'bashrc' file:-

show_system_details() {
    echo "Uptime is"
    uptime
    echo "Cpu details"
    lscpu
    echo "User list"
    who
}

(ii) source bashrc

(iii) show_system_details  # run this on CLI
# it will show:- uptime, lscpu, who & whichever you write inside that function

# after doing the above, this command will also work:-
type show_system_details
--

# write a script which creates back-up of a file --> trainer included this code in the same 'function-demo.sh' file.

is_file --> is a function. Logic is to just write your shell script inside a function

# side note:
# trainer said indentation doesn't matter while he was writing an if stmt.

Notice that the is_file() function is taking an arguement --> "$1"